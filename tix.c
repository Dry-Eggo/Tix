#include "src/build/build_opt.h"
#include "src/internals.h"
#include "src/lexer.h"
#include "src/nasm_generator.h"
#include "src/node.h"
#include "src/parser.h"
#include "src/token_list.h"
#include <stdio.h>
#include <stdlib.h>
static const char *version = "v0.1.0";
static ARGDef commands[] = {
    {"Available targets:\n\t* x86_64 nasm"},
    {"Set the path of the output generated by the compiler"},
    {"Display the current version of the compiler installed on this machine"},
    {"Error: No such command"},
};
extern void print_usage(const char *program) {
  fprintf(stdout, "USAGE:  %s [OPTIONS] <path-to-file>", program);
  fprintf(stdout, "\nOPTIONS:");
  fprintf(stdout,
          "\n    --help        | -h                 print this message");
  fprintf(stdout, "\n    --output      | -o                 set output path");
  fprintf(stdout, "\n    --version     | -v                 display version");
  fprintf(stdout,
          "\n    --target      | -t                 set target output: see "
          "--help target");
  fprintf(stdout, "\n    --build       |                    build a project "
                  "that was initialized by the compiler");
  fprintf(stdout, "\n    --init        |                    initialize a "
                  "project in \033[33mcurrent directory\033[0m");
  fprintf(stdout,
          "\n    --run         |                    run an executable built by "
          "the compiler for a project initialized by the compiler");
  fprintf(stdout, "\n    --build-run   |                    runs --build and --run");
  fprintf(stdout,
          "\n    --clean       |                    clean artifacts made by "
          "the compiler's build system");
  fprintf(stdout, "\n");
}

int main(int argc, char **argv) {
  BuildOptions bld = {.show_help = false, .show_version = false};
  parse_arguments(&bld, argc, argv);
  if (bld.show_help && !bld.help_target) {
    print_usage(argv[0]);
    exit(1);
  } else if (bld.has_specialized_help_target) {
    printf("%s\n", commands[bld.help_target].help);
    exit(1);
  }
  if (bld.show_version) {
    printf("version: %s\n", version);
    exit(1);
  }
  TLexer lexer;
  if (tix_lexer_init(&lexer, bld.inputfile) == 0) {
    return EXIT_FAILURE;
  }
  Token token;
  TokenList tokens;
  token_list_init(&tokens);
  do {
    token = tix_lexer_next_token(&lexer);
    // tix_token_print(&token);
    token_list_add(&tokens, token);
  } while (token.kind != TEOF);
  TParser p;
  stream_max = TString_cstr_to_cstr_array(lexer.stream, &p.source);

  Program pr;
  program_init(&pr);
  parser_init(&p, &tokens);
  parser_parse(&p, &pr);
  NASM64_generator *gen;
  NASM64_init(&gen, pr, p.source, &bld);
  NASM64_generate(gen);
  NASM64_deinit(gen);
  return EXIT_SUCCESS;
}
